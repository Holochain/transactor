'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  // any genesis code here
  return true;
}

// -----------------------------------------------------------------
//  validation functions for every DHT entry change
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the DHT
 * @param {string} entryName - the name of entry being modified
 * @param {*} entry - the entry data to be set
 * @param {?} header - ?
 * @param {?} pkg - ?
 * @param {?} sources - ?
 * @return {boolean} is valid?
 */
function validateCommit (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Transaction":
      // validation code here

      return true;
    case "ProofOfDeposit":
      var validIdentitityForDeposit = canDeposit(App.Agent.String);
      return validIdentitityForDeposit;

    default:
      // invalid entry name!!
      return false;
  }
}

/**
 * Called to validate any changes to the DHT
 * @param {string} entryName - the name of entry being modified
 * @param {*} entry - the entry data to be set
 * @param {?} header - ?
 * @param {?} pkg - ?
 * @param {?} sources - ?
 * @return {boolean} is valid?
 */
function validatePut (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Transaction":
      debug(pkg.Chain.Hashes[1]);
      debug(pkg.Chain.Entries[1]);
      // validation code here
      return true;

    default:
      // invalid entry name!!
      return false;
  }
}

/**
 * Called to validate any changes to the DHT
 * @param {string} entryName - the name of entry being modified
 * @param {*} entry - the entry data to be set
 * @param {?} header - ?
 * @param {*} replaces - the old entry data
 * @param {?} pkg - ?
 * @param {?} sources - ?
 * @return {boolean} is valid?
 */
function validateMod (entryName, entry, header, replaces, pkg, sources) {
  switch (entryName) {
    case "Transaction":
      // validation code here
      return false;
    default:
      // invalid entry name!!
      return false;
  }
}

/**
 * Called to validate any changes to the DHT
 * @param {string} entryName - the name of entry being modified
 * @param {string} hash - the hash of the entry to remove
 * @param {?} pkg - ?
 * @param {?} sources - ?
 * @return {boolean} is valid?
 */
function validateDel (entryName, hash, pkg, sources) {
  switch (entryName) {
    case "Transaction":
      // validation code here
      return false;
    default:
      // invalid entry name!!
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryName) {
  var req = {};
  req[HC.PkgReq.Chain]=HC.PkgReq.ChainOpt.Full;
  return req;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryName) {
  return null;
}

function TransactionCreate(params) {
    debug("I AM: "+ App.Key.Hash);
  var from, to;
  if (params.role === 'spender') {
    from = App.Key.Hash;
    to = params.who;
  }

  var potentionEntry = {
    from: from,
    to: to,
    amount: params.amount,
    description: params.description
  };

  var response = send(to, potentionEntry);
  debug('XXX' + response);
  if(response) {
    return commit('Transaction', potentionEntry);
  }
}

function TransactionRead(params) {
    debug("I AM: "+ App.Key.Hash);
  var data = get(params.transaction);

  var transaction = null;
  if (typeof data === 'object') {
    transaction = data;
  } else {
    try {
      transaction = JSON.parse(data);
    } catch (e) {
      debug(e);
    }
  }

  return transaction;
}


// Proof Of Deposit
function ProofOfDepositCreate(params) {
  var rate = getRate(params.rateHash);

  if (!rate) {
    return null;
  }

  if (!params.proof || !params.proof.id) {
    return null;
  }

  if (!params.amount || params.amount <= 0) {
    return null;
  }

  var value = params.amount * rate;

  var depositHash = commit('ProofOfDeposit', {
    depositReceipt: { id: params.proof.id },
    amount: value,
    currency: params.currency,
    depositor: params.depositor,
    rateHash: params.rateHash
  });

  var transactionHash = TransactionCreate({
    who: params.depositor,
    amount: value,
    role: "spender",
    description: "Credit limit increase"
  });

  return {
    deposit: depositHash,
    transaction: transactionHash
  };
}

function ProofOfDepositRead(params) {
  var transactionData = get(params.transaction);
  var depositData = get(params.deposit);

  var transaction = null, deposit = null;
  try {
    transaction = JSON.parse(transactionData);
    deposit = JSON.parse(depositData);
  } catch (e) {
    // TODO: implement
  }

  debug(transaction);
  debug(deposit);

  return transaction;
}

function getRate(hash) {
  if(hash === "123") {
    return 10;
  }
}

function canDeposit(identity) {
  return identity === 'superbosstoken';
}

function receive(from, msg) {
  if (msg.to !== App.Key.Hash) {
    return null;
  }

  debug(App.Key.Hash + ' ' + JSON.stringify(msg, null, ''));

  return commit('Transaction', msg);
}




function GetBalance() {
  var me = App.Key.Hash
    , history = query({Constrain: {'EntryTypes': ["Transaction"]}})
    , balance = 0


  history.forEach(function(entry) {
    if (entry.from === me) balance -= entry.amount
    else balance += entry.amount
  })

  return balance
}



function GetUserProfile() {
  return {
    pub: App.Key.Hash
  }
}
